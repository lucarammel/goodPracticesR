# Documentation des Bonnes Pratiques en R

## Sommaire

1. [Basic and overall](#basics-and-overall)
2. [Organisation d'un projet](#organisation-dun-projet)
3. [Documentation des Fonctions avec roxygen2](#documentation-des-fonctions-avec-roxygen2)
4. [Gestion des Paquets](#gestion-des-paquets)
   - 4.1 [Installation et Chargement des Paquets](#installation-et-chargement-des-paquets)
5. [Manipulation et Analyse des Données](#manipulation-et-analyse-des-données)
6. [Tests et Validation](#tests-et-validation)
   - 6.1 [Tests Unitaires avec testthat](#tests-unitaires-avec-testthat)
7. [Collaborer avec Git et GitHub](#collaborer-avec-git-et-github)
   - 7.1 [Gestion de Version](#gestion-de-version)
   - 7.2 [Bonnes Pratiques de Collaboration](#bonnes-pratiques-de-collaboration)

## Du bon sens ..

- **Coder en anglais!**  ->  Pour éviter les charactères spéciaux
- **Choisir une police!** -> `snake_case` ou `camelCase`
- **Espacer le code** -> Faites respirer votre code ! Aller à la ligne pour améliorer la lisibilité
- **Choisissez un nom de variable cohérent** -> On oublie les raccourcis, les abbréviations. Mieux vaut un nom long qu'un raccourci incompréhensible.
- **1 fonction  = 1 action** -> On splitte le code le plus possible en fonction pour le rendre lisible et maintenable !
- **Pas de commentaire inutle** -> Les commentaires doivent apporter qqch, inutile de garder du code commenté ! Un code bien fait, n'a pas besoin de commentaire intempestif !
- **Pas de harcode !** -> Il génère des bugs, il empêche une bonne lecture du code, il empêche un débugage correcte, et en plus souvent on y trouve des mots de passe !!

> Pour stocker des variables sensibles on pourra utiliser le fichier `.Renviron` et faire appelle aux différentes variables via un `Sys.getenv('variable_name')`

## Organisation d'un projet

Pour un projet de datascience on s'inspirera de l'architecture suivante :

```raw
project_name
├─ README.md         # A markdown file that provides an overview of the project, including how to set it up, use it, and any other relevant information.
├─ data              # Directory for storing datasets used in the project.
│  ├─ external       # Subdirectory for storing external data sources that are imported into the project.
│  └─ raw            # Subdirectory for storing raw data that hasn't been processed yet.
├─ docs              # Directory for documentation files, which may include detailed explanations, tutorials, and other project-related documents.
├─ results           # Directory for storing results generated by the project.
│  └─ user           # Subdirectory for user-specific results or outputs.
└─ <package_name>    # Directory for source code and scripts.
   ├─ DESCRIPTION    # A file describing the project, its purpose, and other metadata. Used in R projects for package information.
   ├─ NAMESPACE      # A file that defines the functions and objects that are exported by the package and those that are imported from other packages.
   ├─ man            # Subdirectory for R docstring, accessed by ?<name_function>
   └─ R              # Subdirectory for R scripts containing functions, classes, and other R code.
```

```r
# Pour créer un package R from scratch
devtools::create("path/to/package_name")

# Pour générer la documentation 
# Il faut d'abord avoir rédiger la docstring correctement
devtools::document("path/to/package_name")

# Construire la documentation technique du package en PDF
devtools::build_manual("path/to/package_name")

# Construire l'archive du package
devtools::build("path/to/package_name")

# Pour ajouter des dépendances à votre package
usethis::use_package('dependency_name')

# Pour run tous les tests unitaires
devtools::test()
```

## Documentation des Fonctions avec roxygen2

- Utiliser roxygen2 pour documenter les fonctions :

```r
#' Calculate the mean of a numeric vector
#'
#' This function takes a numeric vector as input and returns the mean
#' of the values in the vector. If the vector is empty or contains only NA values,
#' the function returns NA.
#'
#' @param x (numerical vector)
#' @param na.rm (boolean) Indicating whether NA values should be removed
#' before calculation. Defaults to FALSE.
#' @return (float | NA) The mean of the numeric vector. If the vector is empty or contains
#' only NA values, NA is returned.
#' @examples
#' calculate_mean(c(1, 2, 3, 4, 5))
#' calculate_mean(c(1, 2, NA, 4, 5), na.rm = TRUE)
#' calculate_mean(c(NA, NA, NA))
#' @export
calculate_mean <- function(x, na.rm = FALSE) {
  # Check if input is a numeric vector
  if (!is.numeric(x)) {
    stop("Input must be a numeric vector")
  }
  
  result <- mean(x, na.rm = na.rm)
  
  return(result)
}

```

## Gestion des Paquets

### Installation et Chargement des Paquets

```r
devtools::install('<path_to_project>') # for a project/repo 

install.packages('<lib_name>') # for a CRAN available library

install.packages('<path_to_archive>') # for a tar.gz archive for example
```

> Pour ne pas avoir des interférences et soucis de compatabilités entre plusieurs projets. On utilisera [`renv`](https://rstudio.github.io/renv/articles/renv.html). L'outil de gestion des environnements virtuels sur R.>

## Manipulation et Analyse des Données

- Il existe 3 formats de tableaux :
  - `data.frame` -> librarie de base
  - [**`tibble`**](/cheatsheet/dplyr.pdf) -> syntaxe la plus claire et lisible. Fais partie de l'écosystème `dplyr`, `tidyverse`
  - [**`data.table`**](/cheatsheet/datatable.pdf) -> La librairie la plus **rapide** et de très loin. Parfaite pour de très gros volume de données

Utilisez tout sauf `data.frame` qui a une syntaxe proche de pandas certes mais et avec de pauvres performances.

> **Notez** qu'il y des porosités entre les packages mais impliquent des changements de type de tableaux et une clarté appauvrie de la technologie utilisée !

> Pour modifier le tableau en place et ne pas le réaffecter, on peut utiliser `%<>%` du package `magrittr`. Cela fonctionne pour n'importe quel autre type de variable

Exemple :

```r
# Avec tibble / dplyr 
df = df %>% 
    select(product_id, sales) %>%
    filter(sales > 200) %>%
    mutate(sales_tax = sales * 0.1) %>%
    group_by(product_name) %>%
  summarise(total_sales = sum(sales))

# Avec data.table
dt <- dt[, .(product_id, sales)] %>% 
        .[sales > 200]  %>% 
        .[, sales_tax := sales * 0.1] %>%
        .[, .(total_sales = sum(sales)), by = product_name]
```

> PS : L'opérateur `:=` pour déclarer une nouvelle colonne dans un tableau `data.table` affecte le tableau initial. Il ne retourne pas un nouvel objet.

## Tests et Validation

### Tests Unitaires avec testthat

- Écrire des tests unitaires avec testthat :

```r
library(testthat)
library(package_name)

test_that("add_numbers works correctly", {
  expect_equal(add_numbers(1, 2), 3)
  expect_equal(add_numbers(-1, -2), -3)
  expect_equal(add_numbers(0, 0), 0)
  expect_error(add_numbers("a", "b"), "non-numeric argument")
})
```

- Structurer les tests dans un projet.

## Collaborer avec Git et GitHub

### Gestion de Version

- Introduction à Git.
- Utilisation de GitHub pour la collaboration.

### Bonnes Pratiques de Collaboration

- Workflow de collaboration avec Git.
- Revue de code et pull requests.

